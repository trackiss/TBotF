## 任天堂™ ゲームボーイ サウンドシステム (PAPU) ガイド v0.99.21.pre.J3 (03/23/2020)

<br>

このドキュメントは、 **Nintendo(TM) Gameboy sound system (PAPU) guide, v0.99.21.pre (11/04/2005)** を trackiss が (超) 意訳し、Markdown フォーマットに改変したものです。  
読みやすさ優先で訳しているので、翻訳精度云々どころか、勝手に書き足した文章も少なくないです。少なくとも内容は正しいハズです。  
いかんせん原文が古いので、間違っている部分も幾つかあります。その点に関しては、私が把握している範囲でフォローしてあります。

<br>

<br>

---

**このドキュメントはオフィシャルなものですが、リリース版ではありません。間違いがあれば報告してください！**

このドキュメントは、Jonathan Gevaryahu、そしてその他多くのユーザーの助けによって書かれています。  
電子メール: "lord_nightmare at users d0t sourceforge d0t net"

freenode (#gnuboy)、または EFnet (#gameboy, #nesdev) でも私を見つける事ができます。

(このドキュメントは、とても便利で実用的な NESSOUND.txt (Brad Taylor 著) と同じ書式で書かれています。もしあなたがファミコンハックをするときに NESSOUND.txt が役立ったのであれば、この GBSOUND.txt もゲームボーイハックをするときに役立つ事でしょう)

もしこのドキュメントの中に間違いがあったなら、いつでも私に連絡してください！

このドキュメントの最新版は、http://www.philly.net/gevaryah/GBSOUND.txt からいつでも入手可能です。  
ジョシュアのホームページ: http://www.joshuawise.com/~nightmare/GBSOUND.txt  
GameBoy Dev'rs: http://www.devrs.com/gb/files/hosted/GBSOUND.txt

> <span style="color: red">訳者注:</span>  
GameBoy Dev'rs のリンク以外は全てリンク切れです。また、GameBoy Dev'rs のリンクも最新版ではありません。  
最新版は https://github.com/bogger33/jgbe で更新されています。と言っても、最終更新は 2005 年ですが。

全ての情報は、これまでのアーカイブによるものです (かの有名な pandocs.txt を筆頭に、NO\$GMB エミュレータの作者 Martin Korth 氏による総合ドキュメント、Jeff Frohwein 氏による様々なテスト、そして私自身の試行錯誤など)。

**未検証** の部分には、これまでの経験に基づく高度な推測が書かれています。  
**一部検証済み** の部分には断片的な情報が書かれていますが、あくまで明確に検証されたものではありません。  
**ほぼ検証済み** の部分には、もう少し検証結果が必要です。

また、Brad Taylor 氏はこう言っています。

> とりわけ、Matthew Conte 氏が提供してくれた擬似乱数生成に関する知識のおかげで、ファミコンのノイズチャネル部の完全なリバースエンジニアリングが達成されました。もし彼の助けがなかったなら、私は今でも干し草の中から針を探し続けていたでしょう…

ゲームボーイの PRNG (擬似乱数生成器) はファミコンと非常に似ているので、これは同様に当てはまります。

<br>

それはさておき…

<br>

---

## まえがき

DMG (ゲームボーイ)、MGB (ゲームボーイポケット)、LGB (ゲームボーイライト)、SGB (スーパーゲームボーイ)、CGB (ゲームボーイカラー)の CPU (Z80 プロセッサと非常に似ている為、GB-Z80 とも呼ばれます)は、内部に 4 つのセミアナログサウンドチャネルを持っています。  
これら4つ、そしてカートリッジからの1入力 (Vin) は、それぞれ出力端子 (左チャネル、右チャネル) のどちらか一方または両方に出力する事ができ、これにより擬似的なステレオサウンドを表現しています。  
ゲームボーイのサウンドジェネレータ (しばしば、PSG (プログラマブルサウンドジェネレータ) と呼ばれるもの) は CPU 内部に組み込まれており、APU (Audio Processing Unit、音声処理装置) または PAPU (Pseudo APU、擬似音声処理装置) と呼ばれています。  
ただし、プログラミング的な観点からして、メインプロセッサと区別して考えられる場合が多いです (もちろん、メインプロセッサとクロックを共有する部分についてはこの限りではありません)。

それでは、このサウンドジェネレータの内部機構についてできる限り詳しく説明していきます。

<br>

---

## 各チャネルの概要

ゲームボーイは、それぞれ独立した 4 つのサウンドチャネルを持っています。

チャネル 1 は、エンベロープ機能と、周波数掃引機能を持つ矩形波チャネルです。

チャネル 2 は、エンベロープ機能のみを持つ矩形波チャネルです。

チャネル 3 は、32ステップ/4bit のプログラマブルなウェーブテーブルチャネルです。

チャネル 4 は、エンベロープ機能を持つホワイトノイズチャネルです。

チャネル 1～3 は 64～131,072Hz の周波数、チャネル 4 は 2～1,048,576Hz の周波数を、それぞれ生成する事ができます。

> <span style="color: red">訳者注:</span>  
pandocs.txt によれば、チャネル 3 の出力周波数は 32～65,536Hz です。

**注:** ビデオ同期の問題により、SGB は他の機種よりもプロセッサがおよそ 2.4% 高速に動作します。これに伴い、サウンド周波数もおよそ 2.4% 高く出力されます。

> <span style="color: red">訳者注:</span>  
SGB は、スーパーファミコン (以下、SNES) の CPU クロックを 5 分周 (1/5) して使用しており、実機とクロック周波数が微妙に異なります。  
NTSC 方式を採用している地域で発売された SNES は、NTSC 方式の色信号速度 3.579545MHz を 6 倍した 21.47727MHz で動作しています。  21.47727MHz / 5 = 4.295454MHz という事で、実機よりも 2.354815% 早いです。約 2.4%。  
それ以外の地域で発売された SNES は、PAL 方式の色信号速度 4.43361875MHz の 4/5 を 6 倍した 21.27139MHz で動作しています。  
21.27139MHz / 5 = 4.254278MHz ですので、実機より 1.409734% 早い事になります。

> <span style="color: red">訳者注:</span>  
日本でのみ発売された SGB2 (スーパーゲームボーイ 2) は、カセット内部に水晶振動子を搭載している為 通常のクロック周波数で動作します。

<br>

---

## アドレスとレジスタ

各サウンドチャネルにアクセスする為のアドレスは、以下の通りです。

| アドレス        | 説明                 | 呼称        |
| --------------- | -------------------- | ----------- |
| \$FF10 - \$FF14 | チャネル 1           | NR10 - NR14 |
| \$FF15          | 未使用<sup>\*1</sup> | -           |
| \$FF16 - \$FF19 | チャネル 2           | NR21 - NR24 |
| \$FF1A - \$FF1E | チャネル 3           | NR30 - NR34 |
| \$FF1F          | 未使用<sup>\*2</sup> | -           |
| \$FF20 - \$FF23 | チャネル 4           | NR41 - NR44 |
| \$FF24          | Vin の制御           | NR50        |
| \$FF25          | 各チャネル出力の制御 | NR51        |
| \$FF26          | 電源の制御           | NR52        |
| \$FF27 - \$FF2F | 未使用               | -           |
| \$FF30 - \$FF3F | ウェーブテーブル     | -           |

\*1 = チャネル 2 の周波数掃引機能の為に予約されていたと推測されます

\*2 = チャネル 4 の為に予約されていたと推測されます

**未検証:** 各チャネルのアドレスは、初期化フラグレジスタを除き、全て読み書き可能です。

**一部検証済み:** \$FF30 - \$FF3F は常に読み書き可能ですが、チャネル 3 がオンになる (\$FF1Eのビット 7 で初期化される) と、わずかにバラつきます (サンプル的回転によるもの？)。

> <span style="color: red">訳者注:</span>  
このサンプル的回転 (rotated-samplewise) ってなんですか… 有識者の方、教えてください。

**検証済み:** \$FF26 の下位 4bit は書き込む事ができますが、効果はありません。  
\$FF26 (NR52) のビット 7 に `0` を書き込むと、APU の電源がオフになり、バッテリ持続時間がおよそ 15～20% 向上します。詳細は、[消費電力に関する説明](#power_consumption) を参照してください。また、\$FF30 - \$FF3F のウェーブテーブルレジスタ (下記参照) 以外の全サウンドレジスタの内容が破棄される事に注意してください。

**検証済み:** APU がオフになっている間、\$FF10 - \$FF2F のあらゆるレジスタへの書き込みは意味を成しません (電源をオンにする為の \$FF26 ビット 7 を除く)。ウェーブテーブルレジスタ (\$FF30 - \$FF3F) は、電源の状態にかかわらず読み書きが可能です。

**検証済み:** \$FF26 ビット4 - 6 の読み出しは、その内容に関わらず常に `1` になります。

**未テスト:** \$FF27 - \$FF2F の読み出しは、その内容に関わらず常に `0xFF` になります。

**一部検証済み:** APU の電源がオンになっている場合、\$FF26 (そしておそらく \$FF27 - \$FF2F も) を除くサウンドレジスタの未使用ビットは、理論上、汎用レジスタとして利用可能です。実際にこれをやって退けたプログラムを私は見た事がありませんが、それはほぼ確実に成功するでしょう！

> <span style="color: red">訳者注:</span>  
http://www.geocities.jp/submarine600/html/soundtest.html にて、未使用ビットは読み出し不可である事が検証されています。

オーディオレンジの初期状態を SRAM にダンプする為のテスト ROM を作成してみたところ、このドキュメントの 99.20 以前のバージョンには幾つか間違いがある事がわかりました。隅々まで注意深くチェックしてください！

**Update 99.21:** DuoDreamer 氏のサポートによって、\$FF26 ビット 7 による APU 電源のオン/オフに関する仕組みを、ほぼ完全に理解する事ができました。

各チャネルには 5 つのレジスタが割り当てられており、ファミコンと同様に、それぞれが共通の役割を持っています。

<br>

### セット 1

各チャネルのオン/オフ切り替えと、周波数掃引機能に関するレジスタです。

#### チャネル 1: \$FF10 (NR10) [矩形波1]

| ビット | 説明                                  |
| -----: | ------------------------------------- |
|      7 | 未使用                                |
|  6 - 4 | 周波数掃引頻度 (`0`: 掃引オフ)        |
|      3 | 周波数掃引方向 (`1`: 減少, `0`: 増加) |
|  2 - 0 | 周波数掃引量 (`0`: 掃引オフ)          |

#### チャネル 2, 4: \$FF15 (NR20) [矩形波2], \$FF1F (NR40) [ノイズ]

| ビット | 説明   |
| -----: | ------ |
|  7 - 0 | 未使用 |

#### チャネル 3: \$FF1A (NR30) [ウェーブテーブル]

| ビット | 説明                 |
| -----: | -------------------- |
|      7 | チャネル 3 オン/オフ |
|  6 - 0 | 未使用               |

<br>

### セット 2

矩形波のデューティ比と、サウンド長に関するレジスタです。

#### チャネル 1, 2, 4: \$FF11 (NR11) [矩形波1], \$FF16 (NR21) [矩形波2], \$FF20 (NR41) [ノイズ]

| ビット | 説明                              |
| -----: | --------------------------------- |
|  7 - 6 | デューティ比 (チャネル 1, 2 のみ) |
|  5 - 0 | サウンド長                        |

#### チャネル 3: \$FF1B (NR31) [ウェーブテーブル]

| ビット | 説明       |
| -----: | ---------- |
|  7 - 0 | サウンド長 |

<br>

### セット 3

エンベロープ機能に関するレジスタです。

#### チャネル 1, 2, 4: \$FF12 (NR12) [矩形波1], \$FF17 (NR22) [矩形波2], \$FF21 (NR42) [ノイズ]

| ビット | 説明                                     |
| -----: | ---------------------------------------- |
|  7 - 4 | 初期音量                                 |
|      3 | エンベロープ方向 (`0`: 減少, `1`: 増加)  |
|  2 - 0 | エンベロープ頻度 (`0`: エンベロープオフ) |

**注:** それぞれの頻度は、n/64秒 (n = 1～7) です

#### チャネル 3: \$FF1C (NR32) [ウェーブテーブル]

| ビット | 説明                                                |
| -----: | --------------------------------------------------- |
|      7 | 未使用                                              |
|  6 - 5 | 音量 (`0`: ミュート, `1`: 最大, `2`: 1/2, `3`: 1/4) |
|  4 - 0 | 未使用                                              |

<br>

### セット 4

周波数 (LSB)、及びノイズ生成に関するレジスタです。

#### チャネル 1, 2, 3: \$FF13 (NR13) [矩形波1], \$FF18 (NR23) [矩形波2], \$FF1D (NR33) [ウェーブテーブル]

| ビット | 説明                                        |
| -----: | ------------------------------------------- |
|  7 - 0 | 周波数 下位 8bit (上位 3bit は セット 5 へ) |

#### チャネル 4: \$FF22 (NR43) [ノイズ]

| ビット | 説明                                     |
| -----: | ---------------------------------------- |
|  7 - 4 | シフトクロック周波数 (**s**)             |
|      3 | レジスタシフト幅 (`0`: 15bit, `1`: 7bit) |
|  2 - 0 | 分周比 (**r**)                           |

周波数の計算式:  
`周波数 = 1,048,576 Hz / (r + 1) / 2 ^ (s + 1)`

> <span style="color: red">訳者注:</span>  
微妙にわかりにくい式になっていたので、少し弄っています。  
原文では `周波数 = 524,288 Hz / r / 2 ^ (s + 1)` とした上で、 `r = 0` のときは `r = 0.5` として計算するよう書かれています。

<br>

### セット 5

サウンド再生フラグと、周波数 (MSB) に関するレジスタです。

#### 全チャネル共通: \$FF14 (NR14) [矩形波1], \$FF19 (NR24) [矩形波2], \$FF1E (NR34) [ウェーブテーブル], \$FF23 (NR44) [ノイズ]

| ビット | 説明                                                               |
| -----: | ------------------------------------------------------------------ |
|      7 | 初期化 (チャネル開始のトリガ、またはチャネル初期化) (書き込み専用) |
|      6 | サウンド長のオン/オフ (読み書き可)                                 |
|  5 - 3 | 未使用                                                             |
|  2 - 0 | 周波数 上位 3bit (チャネル 1, 2, 3 のみ) (読み (?) 書き可)         |

<br>

### 制御セット

#### \$FF24 (NR50): Vin (カートリッジ入力) 出力 / マスターボリューム制御

| ビット | 説明                                         |
| -----: | -------------------------------------------- |
|      7 | Vin -> SO2 出力フラグ (`1`: オン, `0`: オフ) |
|  6 - 4 | SO2 (左) 出力レベル (音量)                   |
|      3 | Vin -> SO1 出力フラグ (`1`: オン, `0`: オフ) |
|  2 - 0 | SO1 (右) 出力レベル (音量)                   |

#### \$FF25 (NR51): 各チャネル出力制御

| ビット | 説明                              |
| -----: | --------------------------------- |
|      7 | チャネル 4 -> SO2 (左) 出力フラグ |
|      6 | チャネル 3 -> SO2 (左) 出力フラグ |
|      5 | チャネル 2 -> SO2 (左) 出力フラグ |
|      4 | チャネル 1 -> SO2 (左) 出力フラグ |
|      3 | チャネル 4 -> SO1 (右) 出力フラグ |
|      2 | チャネル 3 -> SO1 (右) 出力フラグ |
|      1 | チャネル 2 -> SO1 (右) 出力フラグ |
|      0 | チャネル 1 -> SO1 (右) 出力フラグ |

#### \$FF26 (NR52): 電源制御, ステータス取得レジスタ

| ビット | 説明                                 |
| -----: | ------------------------------------ |
|      7 | サウンド回路電源フラグ (読み書き可)  |
|  6 - 4 | 未使用 (常に `1` を返す)             |
|      3 | チャネル 4 ステータス (読み出し専用) |
|      2 | チャネル 3 ステータス (読み出し専用) |
|      1 | チャネル 2 ステータス (読み出し専用) |
|      0 | チャネル 1 ステータス (読み出し専用) |

<a name="#power_consumption">

**消費電力に関する重要なお知らせ！！！**  
\$FF26 (NR52) の ビット7 に `0` を書き込むと、APU の電源がオフになり、バッテリ持続時間がおよそ 15～20% 向上します。  
APU が無効になっている間、\$FF10 - \$FF2F 内の全レジスタは初期値 (下記参照) に設定されます。\$FF26 (NR52) の ビット 7 を除き、これらに書き込む事はできません。  
この機能は、長時間 (ポーズ機能を利用しているときなど) サウンド再生が行われない場合や、或いは再生されるサウンド間に大きな無音期間がある場合に使用されます。  
APU 電源の切り替えをすると、SOx 出力ラインにクリックノイズが乗る事に注意してください。電源切り替えの直前に SOx 出力レベルを 0 にしておく事で、クリックノイズを大幅に軽減する事ができます。しかし、これまでに発売された全てのゲームでこれが実践された例はありません。

### レジスタ初期値

ゲームボーイの電源がオンになる、もしくは \$FF26 (NR52) ビット7の書き換えが発生すると、APU のオン/オフサイクルにより、レジスタは下記の通りに設定されます。

**注:** これらは、ブート ROM が実行される前に書き込まれる値です！ また、APU がオフになっている間も同様の値が書き込まれます。

| アドレス        |     値 |
| --------------- | -----: |
| \$FF10 (NR10)   | `0x80` |
| \$FF11 (NR11)   | `0x3F` |
| \$FF12 (NR12)   | `0x00` |
| \$FF13 (NR13)   | `0xFF` |
| \$FF14 (NR14)   | `0xBF` |
| \$FF15 (NR20)   | `0xFF` |
| \$FF16 (NR21)   | `0x3F` |
| \$FF17 (NR22)   | `0x00` |
| \$FF18 (NR23)   | `0xFF` |
| \$FF19 (NR24)   | `0xBF` |
| \$FF1A (NR30)   | `0x7F` |
| \$FF1B (NR31)   | `0xFF` |
| \$FF1C (NR32)   | `0x9F` |
| \$FF1D (NR33)   | `0xFF` |
| \$FF1E (NR34)   | `0xBF` |
| \$FF1F (NR40)   | `0xFF` |
| \$FF20 (NR41)   | `0xFF` |
| \$FF21 (NR42)   | `0x00` |
| \$FF22 (NR43)   | `0x00` |
| \$FF23 (NR44)   | `0xBF` |
| \$FF24 (NR50)   | `0x00` |
| \$FF26 (NR52)   |     \* |
| \$FF27 - \$FF2F | `0xFF` |

\* = **APU の状態に依存します**。APU がオンのときは `0xF0` が、オフのときは `0x70` が書き込まれます

**一部検証済み:** APU が無効のとき、\$FF26 (NR52) は常に `0x70` を示します。

<br>

ブート ROM が実行された後 (コードが実行された直後)、レジスタの値は下記の通りに変動します。

| アドレス      |     値 |
| ------------- | -----: |
| \$FF11 (NR11) | `0xBF` |
| \$FF12 (NR12) | `0xF3` |
| \$FF24 (NR50) | `0x77` |
| \$FF25 (NR51) | `0xF3` |
| \$FF26 (NR52) | `0xF*` |

\* = ブートサウンドを出力するシステムが実行された場合は `1` が、そうでないときは `0` が書き込まれます。ブートサウンドが再生される前後でも、チャネル 1 のステータスは `1` を示します。これは、チャネル 1 が音量 0 のまま再生され続けている為です。エンベロープによって音量を 0 にすると、この"ゾンビ状態" (詳細は後述) が発生します。

> <span style="color: red">訳者注:</span>  
SGB の場合は、"\*" の値は必ず `0` になります。これは、ブートサウンド処理がスーパーファミコン側で行われている為だと推測されます。

ブート ROM 実行後のサウンドレジスタ状態に依存する一部のゲームを適切に動作させる為に、仮にサウンドを再生しないシステムが実行されたとしても、必ずレジスタは上記の状態に設定されます。

(もしあなたがブート ROM を"ついうっかり"コピーしてしまったのなら、これらのレジスタへ書き込まれる過程を覗き見る事が可能です。ブート ROM のデカプセル化の為に DMG-CPU を提供してくれた DuoDreamer 氏、そして Neviksti 氏にはとても感謝しています)

\$FF30 - \$FF3F の初期値については、[ウェーブテーブルメモリ](#wave_table)の項を参照してください。

**検証済み:** APU のオン/オフサイクル中では、それまでに書き込まれていたレジスタの値が全て上記の通りに書き換えられます (ブート ROM 実行後のものではありません)。

**検証済み:** APU の電源がオフになっている間、読み書きは一切受け付けられず、常に上記の通りの値を示します。

<br>

---

## 各チャネルの仕様

ここでは、私が管理しやすいように、チャネル内部の仕組みを詳しく説明します。幾つかの情報はまだ完全にはテストされていない、或いはそして把握しきれていない事に注意してください (特に、"ゾンビ状態"に於けるインクリメントの規則性などです。詳細は[音量・エンベロープ制御装置](#volume_envelope)の項へ)。

**重要なお知らせ！:** 私がオシロスコープを所持していない為、一部の仕様 (カウンタなど) は、ファミコンとゲームボーイの APU がとてもよく (または部分的に) 似ている事に基づく推測から書かれています。このドキュメントのバージョン 1.0 までにオシロスコープを入手できたなら、これらの情報は検証に基づく完全なものになるでしょう。

**Update 99.21:** ドレクセル大学の ECE 部が本当に素晴らしいテスト装置を提供してくれました。私は今オシロスコープを所持しています。このドキュメントに書く為の計測レポートはまだ書いていません。

| 機能 (または機器)              | 矩形波 1 | 矩形波 2 | ウェーブテーブル | ノイズ |
| ------------------------------ | :------: | :------: | :--------------: | :----: |
| 周波数タイマー                 |    X     |    X     |        X         |        |
| 可変タイマー                   |          |          |                  |   X    |
| 長さカウンタ                   |    X     |    X     |        X         |   X    |
| 統合長さクロック               |    C     |    C     |        C         |   C    |
| 4 ビット DAC                   |    X     |    X     |        X         |   X    |
| 音量/エンベロープ制御          |    X     |    X     |                  |   X    |
| マスター出力制御               |    *     |    *     |        X         |   *    |
| 周波数掃引                     |    X     |          |                  |        |
| デューティサイクルジェネレータ |    X     |    X     |                  |        |
| 擬似乱数ジェネレータ           |          |          |                  |   X    |
| ウェーブテーブルメモリ         |          |          |        X         |        |
| ウェーブテーブル再生/シフト    |          |    X     |                  |        |
| SO1/SO2 制御                   |    *     |    *     |        *         |   *    |

C = **全チャネル共通**

<br>

### 周波数タイマー

周波数タイマーは、プログラマブルな 11bit のダウンカウンタです。値が 0 になるとリロードされます。これは、2 つの矩形波チャネル及びウェーブテーブルチャネルで使用されます。ノイズチャネルにも似たようなものはありますが、必ずしも同じものではありません。

#### チャネル 1, 2, 3: \$FF13 (NR13) [矩形波1], \$FF18 (NR23) [矩形波2], \$FF1D (NR33) [ウェーブテーブル]

| ビット | 説明                     |
| -----: | ------------------------ |
|  7 - 0 | 周波数 下位 8bit (7 -0 ) |

#### チャネル 1, 2, 3: \$FF14 (NR14) [矩形波1], \$FF19 (NR24) [矩形波2], \$FF1E (NR34) [ウェーブテーブル]

| ビット | 説明                             |
| -----: | -------------------------------- |
|  2 - 0 | 周波数 上位 3bit (A - 8) (**n**) |

いずれかのビットに値が書き込まれると、周波数レジスタ値を反転した値 +1 (即ち、2 の補数) がターミナルカウント (終端カウント) として設定されます。もしくは、2048 から周波数レジスタ値を減算した値が書き込まれている場合もありますが、いずれも結果は同じです。

これらのレジスタを読み出したとき、返ってくる値は不定です (`0` または `1`？ 未検証)。

このカウンタは、ターミナルカウントに同期してリロードします。つまり、0 になる前に**TC ライン** (ターミナルカウントライン、設定値に応じ上昇する) に達するとリロードされ、またカウントを始めます。これは n クロック周期で繰り返されます。  
このカウンタは 5bit (0～31) タイマーのクロック出力によってカウントされます。このタイマーは、ゲームボーイの CPU クロック周波数である 4.194304MHz に基づいてクロックされています。  
(CGB-CPU の持つ倍速モードは、クロック信号の立ち上がりエッジと立ち下がりエッジの両方で**プロセッサ**クロックを生成しているだけであり、実際のタイマーの速度は変わらず 4.194304MHz のままです)

これにより、出力周波数は以下の計算式から算出できます:  
`周波数 = 4194304 / ((2048 - n) << 5)`

次の式でも同じ結果が得られます:  
`周波数 = 4194304 / ((~n + 1) << 5)`

こっちも:  
`周波数 = 131072 / (~n + 1)`

> <span style="color: red">訳者注:</span>  
n の"2 の補数"を考えるときに、オーバーフローに関する事は考えないようにしてください。  
例えば、`n = 0` のケースがこれに該当します。通常なら、`000 0000 0000` の"2 の補数"は、オーバーフローにより `000 0000 0000` になります。ですが、n は内部的に 12bit またはそれ以上の領域 (おそらく 16bit = 2B でしょう) を持っています。ここでは例外的に、`000 0000 0000` の"2 の補数"は、`1000 0000 0000` と考えるようにしてください。訳者はこのわずかな違いのせいで、数日ほど頭を悩ませ続ける事になりました。  
ややこしいようなら、`周波数 = 131072 / (2048 - n)` の式の方がわかりやすくてシンプルです。

TC ラインは、各チャネルの音声出力 (デューティ比生成、ウェーブテーブル再生、或いは、擬似乱数生成) のトリガとして機能します。

**注:** チャネル 1 の掃引システムは、掃引中にカウンタの内容を書き換えてしまいます。(もし直前と同じ周波数を使うとしても) 新しく周波数の値を書き込まなければなりません ([周波数掃引](#frequency_sweep)の項を参照)。

> <span style="color: red">訳者注:</span>  
ここの文章はタイマーやカウンタの知識がある事を前提とした説明になっているので、軽く説明します。大まかには合っているかと思いますが、あくまで推測になりますのでご注意ください。
> 
> まず、ドキュメントにも書かれているタイマーというのは、CPU のクロック周波数を元に正確な時間を計測する為の機構の事です。今回の場合は 5bit のタイマーですので、0〜31 の範囲を持っています。  
> タイマーの値ははじめ 0 を指しており、CPU のクロック入力がある度にインクリメントされていきます。タイマーがオーバーフローを起こす (この場合は31を超える) と、それがトリガとなり、後述する 11bit カウンタがデクリメントされます。ここまでが、タイマーに於ける 1 サイクルです。  
> オーバーフローしたタイマー値はリロードされて0に戻り、またオーバーフローするまでインクリメントを繰り返し続けます。  
> タイマー値の推移は、鋸歯状波のようなラインを辿ります。  
> インクリメント速度は 4.194304MHz で、なおかつ 1 サイクル中に 32 回のインクリメントが行われるですから、`4,194,304Hz / 32 = 131,072Hz`、これが 5bit タイマーのクロック速度です。  
> 
> 次に 11bit カウンタについてですが、曖昧な点が多く、推測というより個人的な予測に基づいた説明になります。内容の可否には期待しないでください。  
> このカウンタは、矩形波 1、矩形波 2、ウェーブテーブルの各チャネルに 1 つずつ存在します。ドキュメントにてダウンカウンタと説明されている通り、このカウンタの値は最大値から 0 へ向けてデクリメントしていくものと思われます。なお、ドキュメントには 11bit と表記されていますが、その後の説明から 0〜2048 の範囲を持っていると推測されます (つまり、実際には 12bit もしくはそれ以上のメモリ領域が割り当てられている可能性が高いです)。"カウンタ値が 0 になるとリロードされる"と書かれていますが、後述の"ターミナルカウント"により、このカウンタは原則 1〜2048 の範囲を示します。リロードそのものに 1 クロックかかるので、実質的な総ステップ数は 2048 です。  
> 今回は、カウンタ値が"ターミナルカウント" (以下 TC 値) に一致する事によってもリロードするようになっています。TC 値には、レジスタに設定した周波数の"2 の補数" (もしくは"2048 - 周波数") が格納されています。計算式から、 TC 値は 1〜2048 の値を取り得る事がわかります。2048 から 0 に向かってデクリメントしていき、TC 値と一致すると音声出力がトリガされます。直後、カウンタは 1 クロックかけてリロードされ、またカウントが開始されます。  
> なお、TC 値が変更される (≒ レジスタの値が変更される) と同時に、カウンタ値にも同じ値がセットされます。つまり、最初の 1 カウント目は、即座に音声出力がトリガされます。

> ゲームボーイカラー独自の倍速モードについても触れられていますので、これまた推測ですらない個人的予測を述べます。  
> ご存知の通り、ゲームボーイの CPU である LR35902 は 4.194304MHz で動作しますが、実際にゲームカートリッジにクロック信号が送信されるのは 4 クロックに 1 度のみです。即ち、ゲーム上に於いて、CPU は 1.048576MHz として振る舞っているのです。ドキュメントの記述をそのまま信じるならば、倍速モードとは、この"プロセッサクロック"が倍 (2.097152MHz) になっているだけのようです。つまり、倍速モードはあくまで擬似的なもので、CPU そのものの処理速度は変わっていないという事になるでしょう。事実、CPU は同じものが使用されている訳ですし… タイマーは"プロセッサクロック"ではなく CPU のクロックによってカウントされているので、倍速モードによる影響はないという事を言っているのだと思います。

<br>

### 可変タイマー

可変タイマーは、ノイズチャネルに於ける周波数タイマーのようなものとして機能します。これは \$FF22 (NR43) レジスタによって制御され、カスタマイズできる 3 ビットのダウンカウンタと、初期/リロード値として 1 ビットのみ指定できる 16bit ロングダウンカウンタ (シフトクロック) によって構成されています。シフトクロックは、値が 0 になるとリロードされます。  
3bit ダウンカウンタの初期/リロード値は、分周比レジスタの設定によって決定されます。

#### チャネル4: \$FF22 (NR43) [ノイズ]

| ビット | 説明           |
| -----: | -------------- |
|  2 - 0 | 分周比 (**r**) |

3bit ダウンカウンタは、1/2 に分周された CPU クロック (2.097152Hz) によってカウントされます。カウントダウンとリロードには、それぞれ 1 クロックが費やされます。  
リロード時に、出力は反転されます (LOW -> HIGH, HIGH -> LOW)。

```
クロック周波数:    \\\\\\\\\\\\\\\\\\\\\\\\\\\\    2097152 Hz
          比率:  0 _-_-_-_-_-_-_-_-_-_-_-_-_-_-    1048576 Hz
                 1 __--__--__--__--__--__--__--     524288 Hz
                 2 ___---___---___---___---___-  ~370727.6 Hz
                 3 ____----____----____----____     262144 Hz
                 4 _____-----_____-----_____--- ~220435.95 Hz
                 5 ______------______------____  ~185363.8 Hz
                 6 _______-------_______------- ~155871.75 Hz
                 7 ________--------________----     131072 Hz
```

3bit ダウンカウンタの出力は、16bit ダウンカウンタのクロックに使われます。

シフトクロックは 16bit 長のダウンカウンタで、16bit 中のいずれか 1bit を 1 にした値を、初期/リロード値として設定できます。そのビット位置は、シフトクロック周波数レジスタから読み出されます。

**未検証:** シフトクロックのリロードは瞬時に行われます。

#### チャネル4: \$FF22 (NR43) [ノイズ]

| ビット | 説明                         |
| -----: | ---------------------------- |
|  7 - 4 | シフトクロック周波数 (**s**) |

シフトクロックの出力は、擬似乱数ジェネレータ (PRNG) のクロックとして使われます。

`PRNG 周波数 = (1048576 / (r + 1)) / (2 ^ (s + 1))`  
(`^` は XOR ではなく累乗を意味します)

<br>

### 長さカウンタ

ゲームボーイのサウンドチャネルは、それぞれ独立した長さカウンタと、条件付きクロックダウンカウンタを持っています。  
ゲームボーイの PAPU に於ける長さカウンタには、チャネル 1, 2, 4 で使用される 5bit のもの (<span style="color: red;">訳者注:</span> おそらく 6bit の間違い？) と、チャネル 3 で使用される 8bit のものがあります。それぞれのカウンタのクロック入力については、各項で説明します。

次のレジスタを使用して、各チャネルのサウンド長を指定する事ができます。

#### チャネル1, 2, 4: \$FF11 (NR11) [矩形波1], \$FF16 (NR21) [矩形波2], \$FF20 (NR41) [ノイズ]

| ビット | 説明                 |
| -----: | -------------------- |
|  5 - 0 | サウンド長 (**len**) |

レジスタに書き込まれた 5bit の値 (<span style="color: red;">訳者注:</span>おそらく 6bit の間違い？) は、反転されたのちに 1 が加算され、カウンタに格納されます。或いは、64 からレジスタの値を減算したものかも知れませんが、どちらも同じ結果になります。

これらサウンド長カウンタは[統一サウンド長クロック](#) (256Hz) によってクロックされており、統一サウンド長クロックが 1 クロック進むたび (256Hz) にカウントされていきます。

> <span style="color: red">訳者注:</span>  
この統一サウンド長クロックは、実際には 512Hz で駆動している事が判明しており、今ではフレームシーケンサと呼ばれています。つまり、このサウンド長カウンタは、2 クロックごとにカウントされていると見るべきでしょう。

サウンド長の秒数は、以下の式から算出できます:  
`サウンド長 (秒) = (64 - len) * (1/256)`

> <span style="color: red">訳者注:</span>  
つまり、サウンド長は 0.25〜0.00390625 秒の範囲を 64 段階に分けて指定できるという事になります。

**注:** このドキュメントの 99.18 以前のバージョンでは、チャネル 1, 2, 4 のサウンド長カウンタが 64Hz ごとにカウントされていると表記されていました。検証により、それは間違いであった事が判明しています。私に検証をするよう促してくれた方へ感謝します。

#### チャネル3: \$FF1B (NR31) [ウェーブテーブル]

| ビット | 説明                 |
| -----: | -------------------- |
|  7 - 0 | サウンド長 (**len**) |

8bit カウンタへの値の格納は、5bit カウンタ (<span style="color: red;">訳者注:</span> 6bit の間違い？) のそれと同様にして行われます (反転して +1、または 256 から減算)。

クロック入力についても 5bit カウンタ(<span style="color: red;">訳者注:</span> 6bit の間違い… ですよね？) と同様で、統一サウンド長クロックの1クロックごと (256Hz) にカウントされます。

> <span style="color: red">訳者注:</span>  
これも、実際には 2 クロックごと (2/512Hz) にカウントされていると思われます。

サウンド長の秒数は、以下の式から算出できます:  
`サウンド長 (秒) = (256 - len) * (1/256)`

> <span style="color: red">訳者注:</span>  
つまり、チャネル 4 に限り、サウンド長を 1〜0.00390625 秒の 256 段階に分けて指定できるという事になります。

<br>

サウンド長レジスタに値を書き込むと、当該チャネルのオン/オフに関わらず、即座にカウントが始まって発音し始めます！この現象は、サウンド長オン/オフレジスタがオンになっているときであればいつでも発生します。  
幾つかの商用ゲーム、特に"ロックマンワールド 2"や"バルーンファイト 2"がこれを証明しています。

**注:** サウンド長カウンタに最後に書き込まれた値がリロードされる事は、**決して**ありません！ 書き込まれた値はカウント中に破壊される為、発音のたびに手動で値をセットする必要があります。ただし、カウンタが 0 になっているときにチャネルを初期化 ($FF14, $FF19, $FF1E, $FF23 のビット 7) すると、最大長での発音が可能になります。注意してください！

> メモ
> 以下翻訳途中

**検証済み:** サウンド長オン/オフビットがオフになっているときにサウンド長を書き込んでもカウンタの値は変化せず、サウンド長をオンにすると変更が反映されます。これは、そのチャネルが初期化されているかどうかに関わらず、同じ命令を

#### 全チャネル共通: \$FF14 (NR14) [矩形波1], \$FF19 (NR24) [矩形波2], \$FF1E (NR34) [ウェーブテーブル], \$FF23 (NR44) [ノイズ]

| ビット | 説明                               |
| -----: | ---------------------------------- |
|      6 | サウンド長のオン/オフ (読み書き可) |
